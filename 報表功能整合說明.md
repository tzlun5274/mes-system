# 報表功能整合說明

## 整合概述

將主管功能的報表匯出功能整合到報表模組中，實現統一管理，避免功能重複和衝突。

## 整合內容

### 1. 功能整合

#### 原主管功能報表匯出
- **位置**：`workorder/views.py` 第3873行
- **功能**：作業員報工、SMT報工、異常報工等報表匯出
- **格式**：Excel、CSV、PDF
- **權限**：一般登入用戶

#### 報表模組功能
- **位置**：`reporting/` 目錄
- **功能**：生產日報表、作業員績效報表
- **格式**：Excel
- **權限**：報表使用者群組

### 2. 整合後的統一功能

#### 新的報表匯出功能
- **位置**：`reporting/views.py` 新增
- **功能範圍**：
  - 日報表、週報表、月報表
  - 作業員報工報表
  - SMT報工報表
  - 異常報工報表
  - 效率分析報表
  - 生產日報表
  - 作業員績效報表
- **格式支援**：Excel、CSV、PDF
- **權限控制**：報表使用者群組
- **日期範圍**：今日、昨日、本週、本月、自訂範圍

### 3. 技術實作

#### 新增檔案
1. **`reporting/views.py`** - 新增報表匯出相關函數
2. **`reporting/templates/reporting/report_export.html`** - 報表匯出頁面模板
3. **`reporting/urls.py`** - 新增URL路由

#### 修改檔案
1. **`workorder/views.py`** - 移除報表匯出功能，改為重定向
2. **`workorder/templates/workorder/report/supervisor/functions.html`** - 更新連結
3. **`reporting/templates/reporting/index.html`** - 新增報表匯出連結

#### 新增功能函數
- `report_export()` - 報表匯出頁面
- `execute_report_export()` - 執行匯出
- `get_operator_report_data()` - 取得作業員報工資料
- `get_smt_report_data()` - 取得SMT報工資料
- `get_abnormal_report_data()` - 取得異常報工資料
- `get_production_daily_report_data()` - 取得生產日報表資料
- `get_operator_performance_report_data()` - 取得作業員績效資料
- `export_to_excel()` - Excel匯出
- `export_to_csv()` - CSV匯出
- `export_to_pdf()` - PDF匯出（暫時使用Excel）

### 4. 權限管理

#### 統一權限控制
- **報表使用者群組**：可以訪問所有報表功能
- **超級用戶**：自動擁有所有權限
- **一般用戶**：無法訪問報表功能

#### 權限檢查函數
```python
def reporting_user_required(user):
    return user.is_superuser or user.groups.filter(name="報表使用者").exists()
```

### 5. 資料來源

#### 作業員報工資料
- **來源**：`workorder.models.OperatorSupplementReport`
- **欄位**：報工日期、作業員、工單號、工序、數量、異常紀錄等

#### SMT報工資料
- **來源**：`workorder.models.SMTProductionReport`
- **欄位**：設備、報工日期、製令號碼、機種名稱、異常紀錄等

#### 異常報工資料
- **來源**：`OperatorSupplementReport` 和 `SMTProductionReport`
- **篩選條件**：`abnormal_notes` 欄位有內容

#### 生產日報表資料
- **來源**：`reporting.models.ProductionDailyReport`
- **欄位**：日期、作業員、設備、生產線、效率等

#### 作業員績效資料
- **來源**：`reporting.models.OperatorPerformance`
- **欄位**：作業員、工單、產品、數量、時間等

### 6. 使用方式

#### 訪問路徑
1. **報表模組首頁** → 點擊「報表匯出」按鈕
2. **主管功能頁面** → 點擊「報表匯出」按鈕（會重定向到報表模組）

#### 操作步驟
1. 選擇報表類型（作業員報工、SMT報工、異常報工等）
2. 選擇匯出格式（Excel、CSV、PDF）
3. 選擇日期範圍（今日、昨日、本週、本月、自訂）
4. 點擊「匯出報表」按鈕
5. 系統自動下載報表檔案

### 7. 優勢

#### 功能統一
- 避免功能重複
- 統一權限管理
- 統一介面設計

#### 維護便利
- 集中管理報表功能
- 減少程式碼重複
- 便於功能擴展

#### 用戶體驗
- 一致的介面風格
- 統一的操作流程
- 完整的權限控制

### 8. 注意事項

#### 權限設定
- 確保用戶屬於「報表使用者」群組
- 或具有超級用戶權限

#### 資料範圍
- 異常報工只包含有異常紀錄的資料
- 日期範圍支援自訂，但需要驗證日期格式

#### 檔案格式
- Excel格式支援完整樣式
- CSV格式支援中文編碼
- PDF格式暫時使用Excel格式

### 9. 未來擴展

#### 可能的功能擴展
- 新增更多報表類型
- 支援更多匯出格式
- 新增報表預覽功能
- 支援報表排程發送

#### 技術改進
- 實作真正的PDF匯出
- 新增報表模板功能
- 支援報表資料快取
- 新增報表統計分析 

## 📋 MES 報表系統開發設計架構與結構規範

###  一、報表系統總體架構

#### 1.1 系統架構圖
```
┌─────────────────────────────────────────────────────────────┐
│                    報表系統架構                              │
├─────────────────────────────────────────────────────────────┤
│  表現層 (Presentation Layer)                                │
│  ├── 報表查詢介面 (reporting/templates/)                    │
│  ├── 報表匯出介面 (Excel, CSV, PDF)                        │
│  └── 報表儀表板 (Dashboard)                                 │
├─────────────────────────────────────────────────────────────┤
│  業務邏輯層 (Business Logic Layer)                          │
│  ├── 報表生成服務 (reporting/services/)                     │
│  ├── 數據計算引擎 (reporting/calculators/)                  │
│  ├── 智能分配算法 (reporting/allocators/)                   │
│  └── 報表驗證服務 (reporting/validators/)                   │
├─────────────────────────────────────────────────────────────┤
│  數據存取層 (Data Access Layer)                             │
│  ├── 報表模型 (reporting/models.py)                         │
│  ├── 數據查詢器 (reporting/queries/)                        │
│  ├── 數據轉換器 (reporting/transformers/)                   │
│  └── 快取管理 (reporting/cache/)                            │
├─────────────────────────────────────────────────────────────┤
│  數據來源層 (Data Source Layer)                             │
│  ├── 工單管理模組 (workorder/)                              │
│  ├── 設備管理模組 (equip/)                                  │
│  ├── 製程管理模組 (process/)                                │
│  └── ERP整合模組 (erp_integration/)                         │
└─────────────────────────────────────────────────────────────┘
```

#### 1.2 模組職責分工
- **reporting/models.py**: 報表數據模型定義
- **reporting/services/**: 報表業務邏輯服務
- **reporting/calculators/**: 數據計算引擎
- **reporting/allocators/**: 智能分配算法
- **reporting/validators/**: 數據驗證服務
- **reporting/queries/**: 數據查詢器
- **reporting/transformers/**: 數據轉換器
- **reporting/cache/**: 快取管理
- **reporting/templates/**: 報表模板
- **reporting/static/**: 靜態資源

###  二、報表類型與分類規範

#### 2.1 報表分類架構
```
報表系統
├── 工作時間報表 (Work Time Reports)
│   ├── 日報表 (Daily Work Time Report)
│   ├── 週報表 (Weekly Work Time Report)
│   └── 月報表 (Monthly Work Time Report)
├── 工單機種報表 (Work Order Product Reports)
│   ├── 日報表 (Daily Work Order Report)
│   ├── 週報表 (Weekly Work Order Report)
│   └── 月報表 (Monthly Work Order Report)
├── 人員績效報表 (Personnel Performance Reports)
│   ├── 作業員績效報表 (Operator Performance Report)
│   ├── 主管績效報表 (Supervisor Performance Report)
│   └── 團隊績效報表 (Team Performance Report)
├── 設備效率報表 (Equipment Efficiency Reports)
│   ├── SMT設備效率報表 (SMT Equipment Report)
│   ├── 一般設備效率報表 (General Equipment Report)
│   └── 設備維護報表 (Equipment Maintenance Report)
├── 品質分析報表 (Quality Analysis Reports)
│   ├── 不良品分析報表 (Defect Analysis Report)
│   ├── 良率統計報表 (Yield Rate Report)
│   └── 品質趨勢報表 (Quality Trend Report)
└── 綜合分析報表 (Comprehensive Analysis Reports)
    ├── 生產效率分析 (Production Efficiency Analysis)
    ├── 成本分析報表 (Cost Analysis Report)
    └── 產能利用率報表 (Capacity Utilization Report)
```

#### 2.2 報表時間維度規範
- **日報表**: 以單日為統計單位，顯示當日詳細數據
- **週報表**: 以週為統計單位，顯示週內匯總數據
- **月報表**: 以月為統計單位，顯示月度統計數據
- **自訂期間報表**: 支援自訂開始和結束日期

### ️ 三、數據模型設計規範

#### 3.1 基礎報表模型規範
```python
# 所有報表模型的基礎類別
class BaseReportModel(models.Model):
    """報表基礎模型"""
    
    # 報表基本資訊
    report_type = models.CharField(max_length=20, choices=REPORT_TYPE_CHOICES)
    report_date = models.DateField(verbose_name="報表日期")
    report_period_start = models.DateField(verbose_name="報表期間開始")
    report_period_end = models.DateField(verbose_name="報表期間結束")
    
    # 數據來源標示
    data_source = models.CharField(max_length=50, verbose_name="數據來源")
    calculation_method = models.CharField(max_length=50, verbose_name="計算方法")
    
    # 系統資訊
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    created_by = models.CharField(max_length=100, verbose_name="建立者")
    
    class Meta:
        abstract = True
        ordering = ['-report_date']
```

#### 3.2 數據模型命名規範
- **模型名稱**: 使用 PascalCase，以 Report 結尾
- **欄位名稱**: 使用 snake_case
- **外鍵欄位**: 使用 `related_model_id` 格式
- **選擇欄位**: 使用 `CHOICES` 常數定義

#### 3.3 數據完整性規範
- **必填欄位**: 所有關鍵統計欄位必須有值
- **數據驗證**: 數值欄位必須為正數或零
- **百分比欄位**: 範圍限制在 0-100%
- **時間欄位**: 必須符合標準格式

###  四、業務邏輯設計規範

#### 4.1 服務層架構規範
```
reporting/services/
├── __init__.py
├── base_service.py          # 基礎服務類別
├── work_time_service.py     # 工作時間報表服務
├── work_order_service.py    # 工單機種報表服務
├── personnel_service.py     # 人員績效報表服務
├── equipment_service.py     # 設備效率報表服務
├── quality_service.py       # 品質分析報表服務
└── comprehensive_service.py # 綜合分析報表服務
```

#### 4.2 服務類別設計規範
```python
class BaseReportService:
    """報表服務基礎類別"""
    
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def generate_report(self, report_type, date_range, **kwargs):
        """生成報表（抽象方法）"""
        raise NotImplementedError
    
    def validate_data(self, data):
        """驗證數據"""
        pass
    
    def calculate_statistics(self, data):
        """計算統計數據"""
        pass
    
    def format_output(self, data):
        """格式化輸出"""
        pass
```

#### 4.3 計算引擎設計規範
```
reporting/calculators/
├── __init__.py
├── base_calculator.py       # 基礎計算器
├── time_calculator.py       # 時間計算器
├── quantity_calculator.py   # 數量計算器
├── efficiency_calculator.py # 效率計算器
├── cost_calculator.py       # 成本計算器
└── quality_calculator.py    # 品質計算器
```

###  五、智能分配算法規範

#### 5.1 分配算法架構
```
reporting/allocators/
├── __init__.py
├── base_allocator.py        # 基礎分配器
├── time_based_allocator.py  # 時間比例分配器
├── process_based_allocator.py # 工序比例分配器
├── efficiency_based_allocator.py # 效率比例分配器
└── hybrid_allocator.py      # 混合分配器

---

好的，這就為您詳細列出 `HybridAllocator` 的邏輯步驟。考量到您之前提供的資訊，特別是「包裝工序是最後一道工序且只有一名專員」這一關鍵點，我將這部分也融入邏輯中，使分配更精確。

---

## HybridAllocator 詳細邏輯說明

`HybridAllocator` 的核心目標是為那些在報工時未填寫數量（或填寫為零）的作業員，**智能地分配**其應有的產出數量。這個分配過程會基於已知的最終產出和已填寫的數量，並參考作業員的實際工時投入。

### 前置假設與條件

在深入邏輯之前，我們需要明確幾個前置假設：

1.  **工單與工序結構清晰**：系統能明確區分各個工序，特別是能識別出「出貨包裝」工序。
2.  **作業員角色標識**：系統能標識出哪位是「包裝專員」。
3.  **時間數據可用性**：
    * `OperatorSupplementReport` 模型中應包含 `start_time` 和 `end_time` 欄位，以計算作業員的實際工時。
    * 若無明確的時間數據，則需退而求其次，考慮使用「報工次數」作為工時投入的近似值。
4.  **數據庫查詢能力**：`_get_workorder_reports` 函數能正確地從數據庫中查詢到指定工單、日期範圍內的所有報工記錄，並包含作業員、工序、數量、開始時間和結束時間等關鍵資訊。

### `HybridAllocator.allocate()` 方法的邏輯步驟

這個方法將接收一個 `workorder_id` (工單號) 和 `date_range` (日期範圍)，然後執行以下步驟：

---

### 步驟 1：獲取工單所有相關報工記錄

* 呼叫內部方法 `self._get_workorder_reports(workorder_id, date_range)`。
* 此步驟的目的是從數據庫中取出該**特定工單**在**指定日期範圍**內的所有 `OperatorSupplementReport` 記錄。
* 獲取的記錄應包含：作業員資訊（含是否為包裝專員的標識）、工序名稱、報工數量（可能為空或零）、開始時間和結束時間。

---

### 步驟 2：確定「最終工單總產出」

這是整個分配的**基準總量**。

* **識別包裝工序報工：** 從所有報工記錄中，篩選出屬於「出貨包裝」工序且由**包裝專員**提交的報工記錄（要求數量非空且大於零）。
* **計算最終總產出：**
    * 將所有符合條件的**包裝工序報工數量**加總，這將作為該工單在整個生產流程中的「最終總產出」。
    * **重要判斷：**
        * 如果 `最終總產出` 為 `0`（即包裝專員尚未報工或報工數量為零），則表示目前無法確定最終產量，**此時應停止後續的自動分配**。可以選擇：
            * 直接返回原始報工數據（不進行任何分配）。
            * 發出警告或日誌，告知無法分配的原因。
            * 或拋出異常，讓上層調用者處理。
        * （本次設計選擇：返回原始數據並記錄警告）

---

### 步驟 3：分離前序工序的已填寫與未填寫數量報工

* **排除包裝工序報工：** 從所有報工記錄中，**排除**掉步驟2中已處理過的「出貨包裝」工序報工。我們只關注**前序工序**的報工。
* **區分已填寫與未填寫：**
    * **`filled_pre_packaging_reports`**：篩選出這些非包裝工序報工中，**`quantity` 欄位有值且大於零**的記錄。這些是真實報工數據，無需分配。
    * **`unfilled_pre_packaging_reports`**：篩選出這些非包裝工序報工中，**`quantity` 欄位為空或為零**的記錄。這些是需要進行數量分配的目標。

---

### 步驟 4：計算已填寫的數量總和

* 將 `filled_pre_packaging_reports` 中所有報工的 `quantity` **加總**。這代表在最終總產出中，已經有明確來源的數量。

---

### 步驟 5：計算需要分配的剩餘總量

* 使用以下公式計算需要分配給「未填寫數量作業員」的總量：
    * `remaining_quantity_to_allocate = 最終工單總產出 - 已填寫的數量總和`
* **防錯處理：** 如果 `remaining_quantity_to_allocate` 結果為負數（理論上不應發生，除非數據有誤），則將其設置為 `0`，避免分配負數。

---

### 步驟 6：計算未填寫數量作業員的工時比例並進行分配

* **計算工時：** 對於 `unfilled_pre_packaging_reports` 中的每一筆記錄：
    * 使用 `self.time_calculator.calculate_operator_work_time(unfilled_pre_packaging_reports)` 來計算每個作業員在這些未填寫報工中**各自的總工時**。這需要依賴 `start_time` 和 `end_time` 欄位。
    * 同時，計算所有這些未填寫數量作業員的**總工時** (`total_unfilled_work_time`)。
* **執行分配：** 遍歷 `unfilled_pre_packaging_reports` 中的每一筆記錄：
    * **安全檢查：** 如果 `total_unfilled_work_time` 為 `0` (表示所有未填寫數量的作業員都沒有工時記錄)，或者當前作業員沒有工時數據，則該報工無法分配，將其 `allocated_quantity` 設為 `0`。
    * **比例分配：**
        * `分配比例 = 當前作業員的工時 / total_unfilled_work_time`
        * `allocated_qty = round(remaining_quantity_to_allocate * 分配比例)` （使用 `round` 進行四捨五入，確保為整數）。
    * **記錄結果：** 將計算出的 `allocated_qty` 賦值給該報工記錄的 `allocated_quantity` 欄位，並在 `allocation_notes` 欄位中記錄分配依據（例如：「基於工作時間比例分配 (佔比: X%)」）。

---

### 步驟 7：整合所有報表數據

* 將所有三種類型的報工記錄**合併**起來，形成最終的報表數據集：
    * `filled_pre_packaging_reports` (已填寫數量的前序工序報工)
    * `packaging_reports` (包裝工序的最終數量報工)
    * `final_allocated_reports` (經過智能分配的未填寫數量報工)
* 這個整合後的數據集將作為 `allocate()` 方法的返回值，供上層的報表服務進行後續的統計、格式化和匯出。

---

### `_get_workorder_reports()` 方法的邏輯（輔助函數）

這個私有方法負責從數據庫中獲取原始數據。

* **接收參數**：`workorder_id`, `date_range`。
* **數據庫查詢**：使用 Django ORM 或 SQL 查詢語句，從 `workorder.models.OperatorSupplementReport` 模型中，篩選出符合 `workorder_id` 和 `date_range` 條件的所有記錄。
* **關聯查詢**：確保查詢結果能包含相關聯的 `operator` (作業員) 對象，以便獲取其屬性（例如 `is_packaging_personnel`）。
* **返回結果**：返回一個 `OperatorSupplementReport` 對象的列表。

---

### 小結

這個 `HybridAllocator` 的邏輯設計，巧妙地利用了包裝工序的「最終確認產量」作為總量基準，然後再將剩餘的數量按比例分配給那些未填寫數量的作業員，從而解決了數據缺失的問題，使報表數據更為完整和合理。

```

#### 5.2 分配策略規範
- **時間比例分配**: 按工作時數比例分配數量
- **工序比例分配**: 按工序複雜度分配數量
- **效率比例分配**: 按歷史效率分配數量
- **混合分配**: 綜合多種因素進行分配

#### 5.3 分配標示規範
- **原始數量**: 報工時填寫的實際數量
- **分配數量**: 系統智能分配的數量
- **最終數量**: 用於報表顯示的數量
- **分配說明**: 記錄分配計算過程

###  六、前端介面設計規範

#### 6.1 模板結構規範
```
<code_block_to_apply_changes_from>
```

#### 6.2 介面設計規範
- **響應式設計**: 支援桌面和移動設備
- **統一風格**: 使用 Bootstrap 5 框架
- **數據可視化**: 使用 Chart.js 圖表庫
- **互動功能**: 支援篩選、排序、搜尋
- **匯出功能**: 支援 Excel、CSV、PDF 格式

#### 6.3 用戶體驗規範
- **載入提示**: 長時間操作顯示載入動畫
- **錯誤處理**: 友善的錯誤訊息提示
- **數據驗證**: 即時表單驗證
- **操作確認**: 重要操作需要確認
- **結果反饋**: 操作完成後顯示結果

###  七、數據查詢與快取規範

#### 7.1 查詢器設計規範
```
reporting/queries/
├── __init__.py
├── base_query.py           # 基礎查詢器
├── work_time_query.py      # 工作時間查詢器
├── work_order_query.py     # 工單機種查詢器
├── personnel_query.py      # 人員績效查詢器
├── equipment_query.py      # 設備效率查詢器
└── quality_query.py        # 品質分析查詢器
```

#### 7.2 快取策略規範
- **報表快取**: 已生成的報表快取 24 小時
- **統計快取**: 統計數據快取 1 小時
- **查詢快取**: 常用查詢結果快取 30 分鐘
- **快取清理**: 每日凌晨清理過期快取

###  八、報表匯出規範

#### 8.1 匯出格式規範
- **Excel 格式**: 使用 openpyxl 庫，支援多工作表
- **CSV 格式**: 使用 UTF-8 編碼，支援中文
- **PDF 格式**: 使用 reportlab 庫，支援圖表

#### 8.2 匯出內容規範
- **表頭資訊**: 包含報表標題、生成時間、查詢條件
- **數據內容**: 完整的報表數據
- **統計摘要**: 關鍵統計指標
- **圖表附件**: 相關圖表和分析

###  九、權限與安全規範

#### 9.1 權限控制規範
- **報表查看權限**: 報表使用者群組
- **報表匯出權限**: 報表管理者群組
- **報表管理權限**: 系統管理員群組
- **數據修改權限**: 僅限系統管理員

#### 9.2 數據安全規範
- **數據備份**: 定期備份報表數據
- **操作日誌**: 記錄所有報表操作
- **數據加密**: 敏感數據加密儲存
- **存取控制**: 基於角色的存取控制

###  十、開發流程規範

#### 10.1 開發階段
1. **需求分析**: 明確報表需求和功能規格
2. **架構設計**: 設計數據模型和業務邏輯
3. **介面設計**: 設計前端介面和用戶體驗
4. **功能開發**: 實作核心功能
5. **測試驗證**: 單元測試和整合測試
6. **部署上線**: 部署到生產環境

#### 10.2 代碼規範
- **Python 代碼**: 遵循 PEP 8 規範
- **HTML 模板**: 使用 4 空格縮排
- **JavaScript 代碼**: 使用 ES6+ 語法
- **CSS 樣式**: 使用 BEM 命名規範

#### 10.3 文檔規範
- **API 文檔**: 詳細的 API 說明
- **使用手冊**: 用戶操作指南
- **技術文檔**: 開發技術說明
- **維護文檔**: 系統維護指南

###  十一、實施優先級

#### 11.1 第一階段（核心功能）
1. 工作時間報表
2. 工單機種日報表
3. 基礎匯出功能

#### 11.2 第二階段（進階功能）
1. 週報表和月報表
2. 智能分配算法
3. 數據可視化

#### 11.3 第三階段（優化功能）
1. 快取機制
2. 性能優化
3. 用戶體驗提升

 