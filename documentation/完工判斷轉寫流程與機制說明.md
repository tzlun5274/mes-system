# 完工判斷轉寫流程與機制說明

## 一、完工判斷轉寫概述

完工判斷轉寫是 MES 系統的核心功能之一，負責自動檢測工單是否達到完工條件，並將已完工的工單資料從生產中狀態轉移到已完工狀態。

## 二、完工判斷機制

### 2.1 完工條件定義

```python
# 完工條件：出貨包裝報工數量 >= 工單目標數量
PACKAGING_PROCESS_NAME = "出貨包裝"

def check_completion_condition(workorder):
    packaging_quantity = get_packaging_quantity(workorder)
    return packaging_quantity >= workorder.quantity
```

### 2.2 完工判斷邏輯

#### 2.2.1 判斷步驟
1. **檢查工單狀態**：如果工單已經是 `completed` 狀態，直接返回 `True`
2. **獲取出貨包裝數量**：查詢所有已核准的出貨包裝報工記錄
3. **比較數量**：出貨包裝數量 >= 工單目標數量
4. **執行完工流程**：如果達到條件，執行完工轉移

#### 2.2.2 數量計算方式
```python
# 優化版本：從生產中記錄查詢
def _get_packaging_quantity_optimized(workorder):
    packaging_reports = WorkOrderProductionDetail.objects.filter(
        workorder_production__workorder=workorder,
        process_name="出貨包裝",
        report_source='operator_supplement'  # 只統計作業員補登報工
    )
    
    total_quantity = packaging_reports.aggregate(
        total=Sum('work_quantity')
    )['total'] or 0
    
    return total_quantity
```

## 三、完工判斷轉寫流程

### 3.1 主要流程圖

```
開始
  ↓
檢查工單狀態
  ↓
是否已完工？ → 是 → 返回 True
  ↓ 否
獲取出貨包裝數量
  ↓
數量 >= 目標數量？ → 否 → 返回 False
  ↓ 是
執行完工流程
  ↓
更新工單狀態為 completed
  ↓
轉移資料到已完工工單
  ↓
清理生產中記錄
  ↓
刪除原始工單記錄
  ↓
返回 True
```

### 3.2 詳細流程說明

#### 3.2.1 完工判斷階段
```python
def check_and_complete_workorder(workorder_id):
    with transaction.atomic():
        # 1. 獲取工單
        workorder = WorkOrder.objects.get(id=workorder_id)
        
        # 2. 檢查工單狀態
        if workorder.status == 'completed':
            return True
        
        # 3. 獲取出貨包裝數量
        packaging_quantity = _get_packaging_quantity_optimized(workorder)
        
        # 4. 判斷完工條件
        if packaging_quantity >= workorder.quantity:
            # 5. 執行完工流程
            _complete_workorder(workorder)
            transfer_workorder_to_completed(workorder_id)
            return True
        
        return False
```

#### 3.2.2 完工執行階段
```python
def _complete_workorder(workorder):
    # 1. 更新工單狀態
    workorder.status = 'completed'
    workorder.completed_at = timezone.now()
    workorder.save()
    
    # 2. 更新生產記錄
    if workorder.production_record:
        workorder.production_record.status = 'completed'
        workorder.production_record.production_end_date = timezone.now()
        workorder.production_record.save()
    
    # 3. 更新所有工序狀態
    for process in workorder.processes.all():
        process.status = 'completed'
        process.actual_end_time = timezone.now()
        process.save()
```

#### 3.2.3 資料轉移階段
```python
def transfer_workorder_to_completed(workorder_id):
    with transaction.atomic():
        # 1. 獲取原始工單
        workorder = WorkOrder.objects.get(id=workorder_id)
        
        # 2. 計算統計資料
        stats = _calculate_workorder_stats(workorder)
        
        # 3. 建立已完工工單
        completed_workorder = CompletedWorkOrder.objects.create(
            original_workorder_id=workorder_id,
            order_number=workorder.order_number,
            product_code=workorder.product_code,
            company_code=workorder.company_code,
            planned_quantity=workorder.quantity,
            completed_quantity=stats['total_good_quantity'],
            status='completed',
            **stats
        )
        
        # 4. 轉移工序資料
        _transfer_processes(workorder, completed_workorder)
        
        # 5. 轉移報工記錄
        _transfer_production_reports(workorder, completed_workorder)
        
        # 6. 清理生產中資料
        _cleanup_production_data(workorder)
        
        # 7. 刪除原始工單
        workorder.delete()
```

## 四、觸發機制

### 4.1 定時觸發（主要方式）
```python
@shared_task
def auto_check_workorder_completion():
    # 每30分鐘執行一次
    production_workorders = WorkOrder.objects.filter(
        status='in_progress'
    )
    
    for workorder in production_workorders:
        success = WorkOrderCompletionService.check_and_complete_workorder(workorder.id)
        if success:
            logger.info(f"工單 {workorder.order_number} 已成功完工並轉移")
```

### 4.2 手動觸發
```bash
# 檢查特定工單
python3 manage.py 完工判斷轉寫已完工 --workorder-id 1234

# 檢查所有生產中工單
python3 manage.py 完工判斷轉寫已完工

# 乾跑模式
python3 manage.py 完工判斷轉寫已完工 --dry-run
```

## 五、資料轉移詳情

### 5.1 轉移的資料表

| 來源表 | 目標表 | 說明 |
|--------|--------|------|
| `WorkOrder` | `CompletedWorkOrder` | 工單基本資訊 |
| `WorkOrderProcess` | `CompletedWorkOrderProcess` | 工序資訊 |
| `OperatorSupplementReport` | `CompletedProductionReport` | 作業員報工記錄 |
| `SMTProductionReport` | `CompletedProductionReport` | SMT報工記錄 |
| `SupervisorProductionReport` | `CompletedProductionReport` | 主管報工記錄 |

### 5.2 清理的資料表

| 資料表 | 清理方式 | 說明 |
|--------|----------|------|
| `WorkOrderProcess` | 刪除 | 工序記錄 |
| `WorkOrderProcessLog` | 刪除 | 工序日誌 |
| `DispatchLog` | 刪除 | 派工記錄 |
| `WorkOrderAssignment` | 刪除 | 工單分配記錄 |
| `WorkOrderProduction` | 刪除 | 生產記錄 |
| `WorkOrderProductionDetail` | 刪除 | 生產明細記錄 |

### 5.3 保留的資料表

| 資料表 | 保留原因 |
|--------|----------|
| `OperatorSupplementReport` | 原始報工記錄，永久保存 |
| `SMTProductionReport` | 原始報工記錄，永久保存 |
| `SupervisorProductionReport` | 原始報工記錄，永久保存 |

## 六、統計計算機制

### 6.1 工單統計
```python
def _calculate_workorder_stats(workorder):
    # 獲取所有已核准的報工記錄
    operator_reports = OperatorSupplementReport.objects.filter(
        workorder=workorder,
        approval_status='approved'
    )
    
    # 計算統計資料
    total_work_hours = sum(report.work_hours_calculated or 0 for report in operator_reports)
    total_good_quantity = sum(report.work_quantity or 0 for report in operator_reports)
    total_defect_quantity = sum(report.defect_quantity or 0 for report in operator_reports)
    
    return {
        'total_work_hours': total_work_hours,
        'total_good_quantity': total_good_quantity,
        'total_defect_quantity': total_defect_quantity,
        # ... 其他統計資料
    }
```

### 6.2 工序統計
```python
def _calculate_process_stats(process):
    # 獲取該工序的所有報工記錄
    operator_reports = OperatorSupplementReport.objects.filter(
        workorder=process.workorder,
        process=process.process_name,
        approval_status='approved'
    )
    
    # 計算工序統計資料
    total_work_hours = sum(report.work_hours_calculated or 0 for report in operator_reports)
    total_good_quantity = sum(report.work_quantity or 0 for report in operator_reports)
    
    return {
        'total_work_hours': total_work_hours,
        'total_good_quantity': total_good_quantity,
        # ... 其他統計資料
    }
```

## 七、效能優化機制

### 7.1 資料庫索引
```python
# 優化完工判斷查詢的複合索引
models.Index(fields=['workorder_production', 'process_name', 'report_source'], 
            name='idx_prod_detail_completion'),
models.Index(fields=['report_date'], name='idx_prod_detail_date'),
models.Index(fields=['process_name'], name='idx_prod_detail_process'),
```

### 7.2 查詢優化
```python
# 使用生產中記錄而非原始報工記錄
def _get_packaging_quantity_optimized(workorder):
    # 直接查詢 WorkOrderProductionDetail，避免查詢大量原始報工記錄
    packaging_reports = WorkOrderProductionDetail.objects.filter(
        workorder_production__workorder=workorder,
        process_name="出貨包裝",
        report_source='operator_supplement'
    )
    
    return packaging_reports.aggregate(total=Sum('work_quantity'))['total'] or 0
```

### 7.3 事務管理
```python
# 使用資料庫事務確保資料一致性
with transaction.atomic():
    # 所有完工相關操作都在同一個事務中
    _complete_workorder(workorder)
    transfer_workorder_to_completed(workorder_id)
```

## 八、錯誤處理機制

### 8.1 異常處理
```python
try:
    success = WorkOrderCompletionService.check_and_complete_workorder(workorder.id)
    if success:
        logger.info(f"工單 {workorder.order_number} 已成功完工並轉移")
    else:
        logger.debug(f"工單 {workorder.order_number} 尚未達到完工條件")
except Exception as e:
    logger.error(f"檢查工單 {workorder.order_number} 時發生錯誤: {str(e)}")
    # 不拋出異常，避免影響其他工單的處理
```

### 8.2 回退機制
```python
def _get_packaging_quantity_optimized(workorder):
    try:
        # 優化版本查詢
        return optimized_query_result
    except Exception as e:
        logger.error(f"優化版查詢失敗: {str(e)}")
        # 回退到原始方法
        return _get_packaging_quantity(workorder)
```

## 九、監控與日誌

### 9.1 日誌記錄
```python
# 完工判斷日誌
logger.info(f"工單 {workorder.order_number} 出貨包裝數量 {packaging_quantity} 達到目標數量 {workorder.quantity}，開始完工流程")

# 資料轉移日誌
logger.info(f"工單 {workorder.order_number} 成功轉移到已完工模組")

# 清理日誌
logger.info(f"工單 {workorder.order_number} 的生產中資料已清理（原始報工記錄保留）")
```

### 9.2 效能監控
```python
# 效能測試命令
python3 manage.py 測試完工判斷效能 --workorder-id 1234 --iterations 10

# 測試結果
# 原始版本平均耗時: 0.002405秒
# 優化版本平均耗時: 0.002220秒
# 效能提升: 7.7%
```

## 十、總結

完工判斷轉寫機制是一個完整的自動化流程，包含：

1. **智能判斷**：基於出貨包裝數量自動判斷完工條件
2. **安全轉移**：使用事務確保資料一致性
3. **完整備份**：將所有相關資料轉移到已完工表
4. **效能優化**：使用索引和優化查詢提升效能
5. **錯誤處理**：完善的異常處理和回退機制
6. **監控追蹤**：詳細的日誌記錄和效能監控

這個機制確保了工單完工過程的可靠性、效能和可追蹤性。 